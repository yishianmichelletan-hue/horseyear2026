<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Red Packet - Falling Money & Photo Focus</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=WDXL+Lubrifont+SC&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
        #ui-hint {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: white; font-family: 'WDXL Lubrifont SC', sans-serif;
            pointer-events: none; text-shadow: 0 0 10px red; font-size: 1.2rem;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="ui-hint">Drag to rotate • Tap photo to bring it closer</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "gsap": "https://cdn.skypack.dev/gsap"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { gsap } from 'gsap';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 7;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        const loader = new THREE.TextureLoader();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Assets
        const bgTex = loader.load('https://image2url.com/r2/default/images/1771541127367-cf4d5632-6ecc-45d9-b9ce-18b8c4a5fb31.jpg');
        const moneyTex = loader.load('https://image2url.com/r2/default/images/1771541178718-280babeb-6e20-4976-9f39-976cabe8c8f1.png');
        bgTex.colorSpace = THREE.SRGBColorSpace;
        scene.background = bgTex;

        const packetGroup = new THREE.Group();
        const height = 3.0; 
        const width = height * (16/9);

        // --- Packet Sides ---
        const createSide = (url, isBack = false) => {
            const tex = loader.load(url);
            tex.colorSpace = THREE.SRGBColorSpace;
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshBasicMaterial({ map: tex, transparent: true }));
            if(isBack) mesh.rotation.y = Math.PI; 
            return mesh;
        };

        const frontSide = createSide('https://image2url.com/r2/default/images/1771538937670-e9ed0ee8-f94b-41b6-ad93-5992c14d2219.png');
        const backSide = createSide('https://image2url.com/r2/default/images/1771538590326-4112549e-d3bb-4920-adb4-2c17d9478b53.png', true);
        backSide.position.z = -0.01;

        // --- Target PNG Photo ---
        const sideImgTex = loader.load('https://image2url.com/r2/default/images/1771543295400-4804656f-6037-4a61-b70b-b3a999b25e8c.jpg');
        sideImgTex.colorSpace = THREE.SRGBColorSpace;
        const sideImgMat = new THREE.MeshBasicMaterial({ map: sideImgTex, transparent: true, opacity: 0 });
        const sideImgMesh = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 2.5), sideImgMat); 
        sideImgMesh.position.set(width * 0.7, 0, -0.2); 
        sideImgMesh.rotation.y = Math.PI; 
        sideImgMesh.name = "targetPhoto"; 
        sideImgMesh.renderOrder = 2;

        // --- Canvas Text ---
        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1024; canvas.height = 256;
            ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 35;
            ctx.fillStyle = '#ffffff'; ctx.font = 'bold 80px "WDXL Lubrifont SC"';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, canvas.width / 2, canvas.height / 2);
            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace;
            return texture;
        }

        const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(width * 0.9, 0.6), new THREE.MeshBasicMaterial({ map: createTextTexture("骏马奔腾，蝠星高照"), transparent: true }));
        textMesh.position.set(0, 0, -0.15); 
        textMesh.rotation.y = Math.PI;

        packetGroup.add(frontSide, backSide, textMesh, sideImgMesh);
        scene.add(packetGroup);

        // --- Falling Money Logic ---
        const fallingBills = [];
        let hasFlipped = false;
        function spawnMoney() {
            for (let i = 0; i < 8; i++) {
                const bill = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.8, 0.4),
                    new THREE.MeshBasicMaterial({ map: moneyTex, transparent: true, side: THREE.DoubleSide })
                );
                bill.position.set((Math.random() - 0.5) * 10, 6, Math.random() * 2);
                bill.renderOrder = 1;
                scene.add(bill);
                fallingBills.push({ mesh: bill, speed: 0.04 + Math.random() * 0.05, rot: (Math.random() - 0.5) * 0.1 });
            }
        }

        // --- Zooming Logic (UPDATED) ---
        let isZoomed = false;
        let sideImageVisible = false;

        const zoomIn = () => {
            isZoomed = true;
            // Set renderOrder very high to be in front of everything
            sideImgMesh.renderOrder = 9999; 
            sideImgMat.depthTest = false; // Ensures it ignores depth of other objects
            
            gsap.to(sideImgMesh.position, { 
                x: 0, 
                y: 0, 
                z: 5.5, // Brought much closer to camera
                duration: 1.0, 
                ease: "expo.out" 
            });
            gsap.to(sideImgMesh.scale, { 
                x: 3.5, // Enlarged scale
                y: 3.5, 
                duration: 1.0,
                ease: "expo.out"
            });
            gsap.to(packetGroup.position, { z: -5, duration: 1.0 }); 
        };

        const zoomOut = () => {
            isZoomed = false;
            gsap.to(sideImgMesh.position, { 
                x: width * 0.95, 
                y: 0, 
                z: -0.2, 
                duration: 0.8, 
                ease: "power2.inOut", 
                onComplete: () => {
                    sideImgMesh.renderOrder = 2; // Reset order
                    sideImgMat.depthTest = true; // Re-enable depth testing
                }
            });
            gsap.to(sideImgMesh.scale, { x: 1, y: 1, duration: 0.8 });
            gsap.to(packetGroup.position, { z: 0, duration: 0.8 });
        };

        // --- Interaction ---
        let isDragging = false, prevX = 0;

        window.addEventListener('mousedown', (e) => { isDragging = false; prevX = e.clientX; });
        window.addEventListener('mousemove', (e) => {
            if (e.buttons === 1) {
                isDragging = true;
                if(!isZoomed) packetGroup.rotation.y += (e.clientX - prevX) * 0.01;
                prevX = e.clientX;
                
                const rot = Math.abs(packetGroup.rotation.y % (Math.PI * 2));
                const isShowingBack = rot > Math.PI * 0.5 && rot < Math.PI * 1.5;
                
                if (isShowingBack !== sideImageVisible && !isZoomed) {
                    sideImageVisible = isShowingBack;
                    gsap.to(sideImgMat, { opacity: isShowingBack ? 1 : 0, duration: 0.5 });
                    gsap.to(sideImgMesh.position, { x: isShowingBack ? width * 0.95 : width * 0.7, duration: 0.8 });
                }

                if (isShowingBack && !hasFlipped) {
                    spawnMoney();
                    hasFlipped = true;
                    setTimeout(() => { hasFlipped = false; }, 3000);
                }
            }
        });

        window.addEventListener('click', (e) => {
            if (isDragging) return;
            if (isZoomed) { zoomOut(); return; }

            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(sideImgMesh);
            if (intersects.length > 0 && sideImageVisible) zoomIn();
        });

        function animate() {
            requestAnimationFrame(animate);
            if(!isZoomed) textMesh.position.y = Math.sin(Date.now() * 0.002) * 0.08;
            
            for (let i = fallingBills.length - 1; i >= 0; i--) {
                const b = fallingBills[i];
                b.mesh.position.y -= b.speed;
                b.mesh.rotation.z += b.rot;
                b.mesh.rotation.x += b.rot;
                if (b.mesh.position.y < -6) {
                    scene.remove(b.mesh);
                    fallingBills.splice(i, 1);
                }
            }
            
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.fonts.ready.then(() => animate());
    </script>
</body>
</html>